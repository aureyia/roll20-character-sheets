mixin assetAbility(ability)
  //- consider having the attr name converted to snake case?
  .asset-ability
    - var assetBodyPlaceholder=translation[ability.id]
    if ability.Enabled
      input(
        type='checkbox'
        name=`attr_${ability.id}`
        checked
      )
      //- old name=`attr_ability_checkbox_${abilityId}`
    else
      input(
        type='checkbox'
        name=`attr_${ability.id}`
      )
      //- old: name=`attr_assetcheckbox_${abilityId}${number}`
    div.i18n-text(data-i18n=abilityId)!=assetBodyPlaceholder
    if ability.Input
      each input in ability.Input
        - var inputId = `${ability.id}-textinput-${_.kebabCase(field)}`
        label.asset-ability-textinput
          span.i18n-text(data-i18n=inputId)=translation[inputId]
          input(type='text' name=`attr_${inputId}` value='')

mixin assetDescription(asset)
  - var translationDesc = `${asset.id}-description`
  .asset-description(data-i18n=translationDesc)=translation[translationDesc]

mixin assetTextInput(textinput, assetId)
  - let id = `${assetId}-textinput-${_.kebabCase(textinput)}`
  label.asset-textinput
    span.i18n-text( data-i18n=id )=translation[id]
    input(type='text' name=`attr_${id}` value='')
    //- old `attr_field-${field}`

mixin assetMeter(track, assetName)
  section.asset-track-wrapper(title=`Asset resource meter: ${_.capitalize(track.Name)}`)
    - var currentTrack = 0
    while currentTrack <= track.Max
      label.asset-track-box(title=`Set ${_.capitalize(track.Name)} to ${currentTrack}`)
        input(type='radio' name=`attr_assettrack_${assetName}` value=`${currentTrack}`)
        span.asset-track-box-display!=currentTrack
        - currentTrack++


mixin assetCard(asset, options)
  //- - let name = `${id.replace(/asset-/i, "")}`
  - let iconWidth = 64
  - let category = _.kebabCase(asset.Category)
  if options.visiblityToggle === true
    input(class=`${options.classes} ${asset.id}` type='checkbox' name=`attr_${asset.id}`)
    //- formerly `attr_${name}`
  div(class=`asset-card ${options.classes} ${asset.id} category-${category}`)
    span.asset-category=asset.Category
    span.asset-name=asset.Name
    img(height=`${iconWidth/(Math.sqrt(3)/2)}` width=`${iconWidth}` src=`https://raw.githubusercontent.com/aureyia/roll20-character-sheets/starforged-asset-refactor/Ironsworn-Starforged/src/app/img/icons/${asset.id}.svg`).asset-icon
    if asset.Description
      +assetDescription(asset)
    if asset.Input
      each textinput in asset.Input
        +assetTextInput(textinput, asset.id)
    .asset-abilities
      each ability in asset.Abilities
        +assetAbility(ability)
    if asset['Condition Meter'] && options.standalone === false
      +assetMeter(asset['Condition Meter'])

mixin genericAssetBuilder(assetsArray, listId)
  //- Asset Datalist
  input.asset-options-header(type='text' list=listId name='attr_asset' placeholder=translation["type-asset-name"])
  datalist(id=listId)
    each asset in assetsArray
      //- generates classes and outputs to stdout
      //- - console.log(`input[type=checkbox].${asset.id}:checked ~ div.asset-card.${asset.id},`)
      option.i18n-text(data-i18n=`${asset.id}-name` value=asset.Name)=translation[`${asset.id}-name`]
    option.i18n-text(data-i18n=`asset-custom-name` value='custom')=translation[`asset-custom-name`]

  //- Asset Content
  each asset in assetsArray
    +assetCard(asset, { classes: 'hide-element', visiblityToggle: true, standalone: false })
